<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>D-ID Agent</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
      }
      #did-agent-container {
        position: relative;
        width: 100%;
        height: 100%;
        background: #000;
      }
      /* hidden sink to keep audio pipeline warm in some WebViews */
      audio#autoplay-sink { position:absolute; width:0; height:0; opacity:0; }
    </style>
  </head>
  <body>
    <div id="did-agent-container"></div>
    <audio id="autoplay-sink" autoplay playsinline muted></audio>

    <!-- D-ID Agent -->
    <script type="module"
      src="https://agent.d-id.com/v2/index.js"
      data-mode="full"
      data-client-key="YXV0aDB8Njg1NWEzZmU2MDNkMjcxMzBiMjViOGUwOkpUMU5fSXdTSlNXbWV5S0NZOWQzcg=="
      data-agent-id="v2_agt_nzoiZmK1"
      data-name="did-agent"
      data-monitor="true"
      data-target-id="did-agent-container">
    </script>

    <script>
      (function () {
        const SINK = document.getElementById('autoplay-sink');

        async function warmUpAutoplay() {
          // Keep an audio element "playing" (muted) to satisfy some autoplay policies
          // and prevent streams from being suspended in background tabs/webviews.
          try {
            await SINK.play().catch(() => {});
          } catch (_) {}
        }

        async function ensureMicPermission() {
          try {
            if (navigator.permissions && navigator.permissions.query) {
              // Try Permissions API first
              const status = await navigator.permissions.query({ name: 'microphone' });
              if (status.state === 'granted') return true;
              // If 'prompt' or 'denied', still attempt to invoke gUM (may show prompt)
            }
          } catch (_) {}
          // Fallback: call getUserMedia to trigger prompt
          try {
            if (navigator.mediaDevices?.getUserMedia) {
              const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
              // Attach to sink so WebView doesn't suspend it
              try { SINK.srcObject = stream; } catch (_) {}
              return true;
            }
          } catch (_) {}
          return false;
        }

        // Shadow-DOM aware search
        function findInShadow(root, predicate) {
          const seen = new Set();
          function walk(node) {
            if (!node || seen.has(node)) return null;
            seen.add(node);

            // Check current node
            try { if (predicate(node)) return node; } catch (_) {}

            // Traverse light DOM
            for (const child of node.children || []) {
              const found = walk(child);
              if (found) return found;
            }
            // Traverse shadow DOM
            if (node.shadowRoot) {
              const found = walk(node.shadowRoot);
              if (found) return found;
            }
            // If node uses slots, also scan assigned elements
            if (node.tagName === 'SLOT' && node.assignedElements) {
              for (const el of node.assignedElements()) {
                const found = walk(el);
                if (found) return found;
              }
            }
            return null;
          }
          return walk(root);
        }

        function clickMicCtaIfPresent() {
          const match = (el) => {
            const tag = (el.tagName || '').toLowerCase();
            const role = (el.getAttribute?.('role') || '').toLowerCase();
            const aria = (el.getAttribute?.('aria-label') || '').toLowerCase();
            const dataTestId = (el.getAttribute?.('data-testid') || '').toLowerCase();
            const text = ((el.innerText || el.textContent || '') + '').toLowerCase();

            const isButtonish = tag === 'button' || role === 'button' || el.onclick;
            const looksLikeMic =
              /turn\s*microphone\s*on|enable\s*microphone|allow\s*microphone|start\s*microphone/.test(text) ||
              /microphone|mic/.test(aria) ||
              /mic|microphone/.test(dataTestId);

            return isButtonish && looksLikeMic && el.offsetParent !== null; // visible
          };
          const btn = findInShadow(document.documentElement, match);
          if (btn) {
            try { btn.click(); } catch (_) {}
          }
        }

        // Orchestrate: warm up audio, request mic, then keep trying to click CTA
        async function bootstrap() {
          await warmUpAutoplay();
          await ensureMicPermission().catch(() => {});
          // Try immediately; the widget might already be rendered
          clickMicCtaIfPresent();

          // React to agent ready/render events
          window.addEventListener('did-agent-ready', () => {
            setTimeout(clickMicCtaIfPresent, 300);
          });

          // Observe late UI changes
          const mo = new MutationObserver(() => clickMicCtaIfPresent());
          mo.observe(document.documentElement, { childList: true, subtree: true });

          // Retry loop (bounded)
          let attempts = 0;
          const timer = setInterval(() => {
            attempts++;
            clickMicCtaIfPresent();
            if (attempts >= 30) clearInterval(timer);
          }, 400);
        }

        // Kick off after a short tick to let the script tag load
        (async () => {
          try { await bootstrap(); } catch (_) {}
        })();
      })();
    </script>
  </body>
</html>
